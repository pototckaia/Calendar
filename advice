Сlean Architecture
========================

архитектура *должна*:
+ быть тестируемой;
+ не зависеть от UI;
+ не зависеть от БД, внешних фреймворков и библиотек.

Это достигается разделением на слои и следованием Dependency Rule (правилу зависимостей).


Схема слоев 
-------------------------

1. Presentation Layer
Model View Presenter - UI and Presenters
______________
Interactors

2. Domain Layer 
Regular Java Objects

Boundaries 
_____________

3. Data Layer 
Repository Pattern (Gateways)


Deoendency Rule
-------------------------
 - внутренние слои не должны зависеть от внешних. 
То есть наша бизнес-логика и логика приложения не должны зависеть от презентеров, UI, баз данных и т.п.

Слои
-------------------------
1. Entities
Enterprise Business Rules
слой содержит:
+ Entities – функции или объекты с методами, которые реализуют логику бизнеса, общую для многих приложений (а если бизнеса нет, то самую высокоуровневую логику приложения);
+ DTO, необходимые для работы и перехода между слоями.

2. Uses Cases
Application Business Rules

В слое UseCases находятся не только Interactor’ы, но также и Boundaries для работы с презентером, интерфейс для работы с репозиторием, DTO для запроса и ответа(Request/ResponseModel).

Interactor – объект, который реализует use case (сценарий использования), используя бизнес-объекты (Entities).

Use case – это детализация, описание действия, которое может совершить пользователь системы.

Use Cases == Interactor

3. Interface Adapter
Адаптеры между внешним миром (Controllers) и Uses Cases (Presenter and Gateways)
Доступ к данным - Repository == Gateway

Repository
Изначально: объект, инкапсулирующий набор сохраненных объектов в более объектно-ориентированном виде. В нем собран код, создающий запросы, который помогает минимизировать дублирование запросов.
Сейчас: объект, предоставляющий доступ к данным с возможностью выбора источника данных в зависимости от условий.

Gateway - представляет собой разновидность фасада, где мы прячем сложное API за простыми методами. (JSON or XML)

В идеале использовать Repository нужно только через Interactor.
В простых случаях, когда не нужно никакой логики обработки данных, можно вызвать Repository из Presenter’a, минуя Interactor.

Маппинг происходит в слое Interface Adapters, то есть в Presenter и Repository.

4. Framework and Drivers
UI, http-клиент, DB, External Interfaces 

Событие пользователя идет в Presenter, тот передает в Use Case. Use Case делает запрос в Repository. Repository получает данные где-то, создает Entity, передает его в UseCase. Так Use Case получает все нужные ему Entity. Затем, применив их и свою логику, получает результат, который передает обратно в Presenter. А тот, в свою очередь, отображает результат в UI.



Переходы
-------------------------
Перехожы между слоями осуществляются через Boundaries: два интерфейса: один для запроса и один для ответа


Presenter -< | Uses Case Output Port <I>
			 |      ^
			 |      |   
			 |	Use Case Interactor 
			 |      |
			 |      ^
Controller ->|  Use Case Input Port <I>

Пояснение: 

-> Зависимость 
-< Реализация

Controller вызывает метод у InputPort, его реализует UseCase, а затем UseCase отдает ответ интерфейсу OutputPort, который реализует Presenter. 
Все зависимости указывают внутрь на слой UseCase’ов.

Чтобы зависимость была направлена в сторону обратную потоку данных, применяется *принцип инверсии зависимостей* (буква D из аббревиатуры SOLID). 
То есть, вместо того чтобы UseCase напрямую зависел от Presenter’a (что нарушало бы Dependency Rule), он зависит от интерфейса в своём слое, а Presenter должен этот интерфейс реализовать.

Точно та же схема работает и в других местах, например, при обращении UseCase к Gateway/Repository. Чтобы не зависеть от репозитория, выделяется интерфейс и кладется в слой UseCases.

Что же касается данных, которые пересекают границы, то это должны быть простые структуры. Они могут передаваться как DTO или быть завернуты в HashMap, или просто быть аргументами при вызове метода. Но они обязательно должны быть в форме более удобной для внутреннего слоя (лежать во внутреннем слое).


MV*-паттерны
========================
отделить UI-код (View) от кода логики (Presenter, Controller, ViewModel и т. д.) и кода обработки данных (Model). 

Model-View-Controller
-------------------------

+  Model – это данные вашего приложения, логика их получения и сохранения. Зачастую это модель предметной области (domain model), основанная на базе данных или на результатах от веб-сервисов. В некоторых случаях domain model хорошо проецируется на то, что вы видите на экране. Но иногда перед использованием ее необходимо адаптировать, изменить или расширить.


+ View отвечала за отображение UI на экране. Без библиотек виджетов, это означало самостоятельную отрисовку блоков, кнопок, полей ввода и т. п. View также может наблюдать за моделью и отображать данные из неё.

+ Controller обрабатывает действия пользователя и затем обновляет Model или View. Если пользователь взаимодействует с приложением (нажимает кнопки на клавиатуре, передвигает курсор мыши), контроллер получает уведомление об этих действиях и решает, что с ними делать.

Следует отметить, что Controller получает события ввода напрямую, а не через View. Контроллер интерпретирует пользовательский ввод от клавиатуры или мыши, и посылает команды модели и/или представлению внести соответствующие изменения.

Model-View-Presenter
-------------------------
Паттерн MVP описывает, как отделить UI от логики интерфейса (что происходит при взаимодействии с виджетами) и от данных (какие данные отображать на экране).

+ Model
Это данные вашего приложения, логика их получения и сохранения. Зачастую она основана на базе данных или на результатах от веб-сервисов. В некоторых случаях потребуется ее адаптировать, изменить или расширить перед использованием во View.

+ View
Обычно представляет собой форму с виджетами. Пользователь может взаимодействовать с ее элементами, но когда какое-нибудь событие виджета будет затрагивать логику интерфейса, View будет направлять его презентеру.

+ Presenter
Презентер содержит всю логику пользовательского интерфейса и отвечает за синхронизацию модели и представления. Когда представление уведомляет презентер, что пользователь что-то сделал (например, нажал кнопку), презентер принимает решение об обновлении модели и синхронизирует все изменения между моделью и представлением.

Passive View
View ничего не знает о Model, но вместо этого предоставляет простые свойства для всей информации, которую необходимо отобразить на экране. Презентер будет считывать информацию из модели и обновлять свойства во View.

Supervising Controller
View знает о Model и отвечает за связывание данных с отображением. Это делает общение между Presenter и View более лаконичным, но в ущерб тестируемости взаимодействия View-Presenter.

Presentation Model
-------------------------
PresentationModel представляет собой логическое представление пользовательского интерфейса, не опираясь на какие-либо визуальные элементы.

+ Содержит логику пользовательского интерфейса:

+ Предоставляет данные из модели для отображения на экране
PresentationModel может преобразовывать данные из модели так, чтобы они были легко отображены на экране.

+ Хранит состояние пользовательского интерфейса

View может легко извлекать данные из PresentationModel и получать всю необходимую информацию для отображения на экране.

Model-View-ViewModel
-------------------------
ViewModel не может общаться со View напрямую. Вместо этого она представляет легко связываемые свойства и методы в виде команд. View может привязываться к этим свойствам, чтобы получать информацию из ViewModel и вызывать на ней команды (методы). Это не требует того, чтобы View знала о ViewModel. XAML Databinding использует рефлексию, чтобы связать View и ViewModel. Таким образом, вы можете использовать любую ViewModel для View, которая предоставляет нужные свойства.